<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>React学习— | 李锋涛</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <link rel="manifest" href="/manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content=李锋涛   >
  <link rel="apple-touch-icon" href="img/icons/152.png">
  
  
  <meta name="theme-color" content="#0c0c1f">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <link rel="alternate" href="/atom.xml" title="李锋涛" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body class=" ">
  	   <div class="iewarn" id="iewarn">
<div>---------!!!!!!!!!!!!!!!!-----------------</div>
检测到您正在使用IE9或更低版本浏览器访问本站，为了您的阅读体验，本站推荐您使用<a href="https://www.google.com/chrome/" target="_blank" >Chrome浏览器</a> 或者<a href="https://www.mozilla.org/en-US/firefox/products/" target="_blank" >Firefox浏览器 </a> 对本站进行访问

</div>
      <header class="main-header">

<div class="logo nav-list">
<a href="/"><img src=/img/logo1.jpg alt="logo" width="50px" height="50px" /></a>
</div>
<ul class="nav-list nav">

<li class="nav-list">
<a href="/">
<i class="fa fa-home" aria-hidden="true" ></i>
首页
</a>
</li>
<li class="nav-list">
<a href="/about">
<i class="fa fa-youtube-play" aria-hidden="true" ></i>
关于我
</a>
</li>
<li class="nav-list">
<a href="/atom.xml" target="_blank" >
<i class="fa fa-feed" aria-hidden="true" ></i>
订阅我
</a>
</li>
<li class="nav-list lightmode ">
<a href="javascript:;" >
<i class="fa fa-moon-o" aria-hidden="true"></i>
关灯
</a>
</li>
</ul>

</header>
        <article>
  <div class="article-share">
<div id="qrcode">
	<div class="qr-text">
	扫一扫，分享到微信
	<i class="fa fa-window-close-o fa-2" aria-hidden="true"></i>
	</div>
</div>
<ul class="share-content">
<li >
		<i class="fa fa-share-alt" aria-hidden="true"></i>
	</li>
	<li>
		<a ><i class="fa fa-weixin" aria-hidden="true" id="toweixin"></i></a>
	</li>
	<li>
		<a ><i class="fa fa-weibo" aria-hidden="true" id="toweibo"></i></a>
	</li>
	<li>
		<a ><i class="fa fa-twitter" aria-hidden="true" id="totwitter"></i></a>
	</li>
</ul>
</div>
<div class="article main-body" itemscope itemprop="blogPost">
  <div class="article-meta">
    <!--采用相对的时间或者绝对的时间，默认相对-->

<div class="article-date">
  	<time datetime="2018-08-20T07:24:36.000Z" itemprop="datePublished">
  	
  	
  	
  	
  	
    
          
      
      
        
    
    
    
  	
  		
  	
  	
    
    
  	
  	 	
  	
  		
  	
  	
    
    
  	
  	
  	
  		
  	
  	
  	7daysago


  
<div>
read time: 9分钟
</div>
</div>




  </div>
  <div class="article-inner">
   
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      React学习—
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="一：HTML-模板"><a href="#一：HTML-模板" class="headerlink" title="一：HTML 模板"></a>一：HTML 模板</h4><pre><code> 例如： &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;  //react的核心库
&lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;  //提供Dom的相关功能
&lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt; //将JSX语法转换成js语法
</code></pre><h4 id="二：ReactDom-render"><a href="#二：ReactDom-render" class="headerlink" title="二：ReactDom.render()"></a>二：ReactDom.render()</h4><pre><code>&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
&lt;script type=&apos;text/babel&apos;&gt;
    ReactDOM.render(
    &lt;h1&gt;Hello, world!&lt;/h1&gt;,    
    document.getElementById(&apos;example&apos;)
)
&lt;/script&gt;
     总结： JSX部分的script 要加上type=&apos;text/babel&apos;   在script里面写ReactDOM.render(
  把元素添加到里面元素里面)
</code></pre><h4 id="三：jsx语法"><a href="#三：jsx语法" class="headerlink" title="三：jsx语法"></a>三：jsx语法</h4><pre><code>HTML语言直接写在Javascript语言中，不加任何引号，就是JSX语法
  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
 &lt;script type=&quot;text/babel&quot;&gt;
    var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;];
    ReactDOM.render(
     &lt;div&gt;
    {
     names.map(function(name,index){
      return &lt;div key={index}&gt;{name }&lt;/div&gt; })
     }
     &lt;/div&gt;,
     document.getElementById(&apos;example&apos;)
)
&lt;/script&gt;
      总结：这个div标签就是JSX语法。
     JSX语法，最终会被编译为 createElement() 方法
                  推荐：使用 JSX 的方式创建组件
        注意：1：如果在JSX里面添加类，用className代替class. for用htmlFor
      2：在 JSX 中可以直接使用 JS代码，直接在 JSX 中通过 {} 中间写 JS代码即可
      3：在 JSX 中只能使用表达式，但是不能出现 语句！！！
      4：在 JSX 中注释语法：{/* 中间是注释的内容 */}
</code></pre><h4 id="四：组件"><a href="#四：组件" class="headerlink" title="四：组件"></a>四：组件</h4><h5 id="创建组件的三种方法"><a href="#创建组件的三种方法" class="headerlink" title="创建组件的三种方法"></a>创建组件的三种方法</h5><pre><code>React.createClass 方法就是用于生成一个组件类
  &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
  &lt;script type=&quot;text/babel&quot;&gt;
</code></pre><h4 id="1-用React-createClass创建一个组件-HellowMessage"><a href="#1-用React-createClass创建一个组件-HellowMessage" class="headerlink" title="1):用React.createClass创建一个组件  HellowMessage"></a>1):用React.createClass创建一个组件  HellowMessage</h4><pre><code>  var HelloMessage=React.createClass({
  render:function(){
    return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;
}
});
 //在html中输出
 ReactDOM.render(
    //要有闭合标签
    &lt;HelloMessage name=&apos;join&apos;/&gt;,  
   //输入到页面
   document.getElementById(&apos;example&apos;)
 )
 &lt;/script&gt;
</code></pre><h5 id="注意：首字母一定要大写。第二个是，每个组件都要有一个render的方法，用于输出组件。"><a href="#注意：首字母一定要大写。第二个是，每个组件都要有一个render的方法，用于输出组件。" class="headerlink" title="注意：首字母一定要大写。第二个是，每个组件都要有一个render的方法，用于输出组件。"></a>注意：首字母一定要大写。第二个是，每个组件都要有一个render的方法，用于输出组件。</h5><h4 id="2-第二种方式创建组件-通过js函数创建-无状态组件）"><a href="#2-第二种方式创建组件-通过js函数创建-无状态组件）" class="headerlink" title="2): 第二种方式创建组件  通过js函数创建(无状态组件）"></a>2): 第二种方式创建组件  通过js函数创建(无状态组件）</h4><pre><code>          例：function Welcome(props) {
  return (
  // 此处注释的写法 
 &lt;div className=&quot;shopping-list&quot;&gt;
 {/* 此处 注释的写法 必须要{}包裹 */}
  &lt;h1&gt;Shopping List for {props.name}&lt;/h1&gt;
  &lt;ul&gt;
  &lt;li&gt;Instagram&lt;/li&gt;
  &lt;li&gt;WhatsApp&lt;/li&gt;
   &lt;/ul&gt;
    &lt;/div&gt;
    )}
ReactDOM.render(
&lt;Welcome name=&quot;jack&quot; /&gt;,
document.getElementById(&apos;app&apos;)
)
</code></pre><h5 id="注意：-1-函数名必须是大写，react通过这来判断是不是组件"><a href="#注意：-1-函数名必须是大写，react通过这来判断是不是组件" class="headerlink" title="注意： 1 函数名必须是大写，react通过这来判断是不是组件"></a>注意： 1 函数名必须是大写，react通过这来判断是不是组件</h5><h5 id="2-函数必须有返回值-return-，返回值可以是：JSX对象或null"><a href="#2-函数必须有返回值-return-，返回值可以是：JSX对象或null" class="headerlink" title="2 函数必须有返回值(return)，返回值可以是：JSX对象或null"></a>2 函数必须有返回值(return)，返回值可以是：JSX对象或null</h5><h5 id="3-返回的JSX，必须有一个根元素-如例的div"><a href="#3-返回的JSX，必须有一个根元素-如例的div" class="headerlink" title="3 返回的JSX，必须有一个根元素(如例的div)"></a>3 返回的JSX，必须有一个根元素(如例的div)</h5><h5 id="4-组件的返回值使用-包裹，避免换行问题"><a href="#4-组件的返回值使用-包裹，避免换行问题" class="headerlink" title="4 组件的返回值使用()包裹，避免换行问题"></a>4 组件的返回值使用()包裹，避免换行问题</h5><h4 id="3-class创建组件-有状态组件"><a href="#3-class创建组件-有状态组件" class="headerlink" title="3): class创建组件 (有状态组件)"></a>3): class创建组件 (有状态组件)</h4><pre><code>class ShoppingList extends React.Component {
      constructor(props) { 
        super(props)
      }
      // class创建的组件中 必须有rander方法 且显示return一个react对象或者null
      render() {
        return (
          &lt;div className=&quot;shopping-list&quot;&gt;
            &lt;h1&gt;Shopping List for {this.props.name}&lt;/h1&gt;
            &lt;ul&gt;
              &lt;li&gt;Instagram&lt;/li&gt;
              &lt;li&gt;WhatsApp&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/div&gt;
        )
      }
    }
注意点和别的创建组件一样。
</code></pre><h5 id="区别和使用场景："><a href="#区别和使用场景：" class="headerlink" title="区别和使用场景："></a>区别和使用场景：</h5><pre><code>1：如果一个组件仅仅是为了展示数据，那么此时就可以使用 函数组件
2：如果一个组件中有一定业务逻辑，需要操作数据，那么就需要使用 class 创建组件，因为，此时需要使用 state
</code></pre><h4 id="给组件传递数据-父子组件传递数据"><a href="#给组件传递数据-父子组件传递数据" class="headerlink" title="给组件传递数据 - 父子组件传递数据"></a>给组件传递数据 - 父子组件传递数据</h4><pre><code>1： 可以理解为props为从外部传入组件内部的数据。因为react是单向数据流，所以，基本就是props从父级组件向子组件传递数据。
 2：通过this.props来获取传递该组件的所有的数据
 3：props经常被用作渲染组件和初始化状态，它是只读的，不可改变的。
</code></pre><h5 id="props的默认参数"><a href="#props的默认参数" class="headerlink" title="props的默认参数"></a>props的默认参数</h5><pre><code>在组件中，我们为props参数设置一个defaultProps，并且制定它的类型
例如：Item.defaultProps = {
    item: &apos;Hello Props&apos;,
  };
  设置类型
  Item.propTypes = {
    item: PropTypes.string,
  };    
  关于其他的一些类型：
  optionalArray: PropTypes.array,
  optionalBool: PropTypes.bool,
  optionalFunc: PropTypes.func,
  optionalNumber: PropTypes.number,
  optionalObject: PropTypes.object,
  optionalString: PropTypes.string,
  optionalSymbol: PropTypes.symbol,       
</code></pre><h5 id="总结：props是一个从外部传进组件的参数，主要就是从父组件向子组件传递数据。它具有可读性和不变性。"><a href="#总结：props是一个从外部传进组件的参数，主要就是从父组件向子组件传递数据。它具有可读性和不变性。" class="headerlink" title="总结：props是一个从外部传进组件的参数，主要就是从父组件向子组件传递数据。它具有可读性和不变性。"></a>总结：props是一个从外部传进组件的参数，主要就是从父组件向子组件传递数据。它具有可读性和不变性。</h5><h5 id="只能通过外部组件传新的props来渲染子组件。否则子组件的props以及展现形式不会改变。"><a href="#只能通过外部组件传新的props来渲染子组件。否则子组件的props以及展现形式不会改变。" class="headerlink" title="只能通过外部组件传新的props来渲染子组件。否则子组件的props以及展现形式不会改变。"></a>只能通过外部组件传新的props来渲染子组件。否则子组件的props以及展现形式不会改变。</h5><h4 id="关于state-相当于vue里的data"><a href="#关于state-相当于vue里的data" class="headerlink" title="关于state (相当于vue里的data)"></a>关于state (相当于vue里的data)</h4><pre><code>通过this.state给组件设定一个初始的state,在第一次render的时候就会用这个数据来渲染。
state是可以改变的，但是是通过this.setState()方法来修改state.
例：componentDidMount(){
fetch(&apos;url&apos;)
.then(response =&gt; response.json())
 .then((data) =&gt; {
 this.setState({itemList:item});  
}
}
        当我们调用this.setState方法时，React会更新组件的数据状态state,并且重新调用render方法，也就是对组件重新进行渲染。
</code></pre><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><pre><code>通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。
setState可以传两个参数，
1 setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象
2 setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：
</code></pre><h5 id="state总结"><a href="#state总结" class="headerlink" title="state总结"></a>state总结</h5><pre><code>state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问              和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。
</code></pre><h4 id="关于state和props的区别"><a href="#关于state和props的区别" class="headerlink" title="关于state和props的区别"></a>关于state和props的区别</h4><pre><code>1 state是组件自己管理数据，控制自己的状态，可变
2 props是外部传入的数据参数，不可变；
3 没有state的叫做无状态组件，有state的叫做有状态组件；
4 多用props，少用state。也就是多写无状态组件。
</code></pre>
      
    </div>
    
<div class="reward" id="rewardme">
「喜欢，就赞一个呗！(:3 」∠)_ (￣y▽￣)~*」

<div class="reward-qr">
<div class="reward-tks">
「鼓励我写出更好的文字」
<i class="fa fa-window-close" aria-hidden="true"></i>
</div>
<img src= "/img/456.jpg" />
「支付宝」
</div>


<div class="reward-btn" >
<div class="reward-text">赏</div>
</div>


</div>
 
    
    




<div class="copyright">
<blockquote>
<strong>本文链接</strong>:  <a href= "http:lilyfengtao.github.io/2018/08/20/React学习—一/" href="_blank" > http:lilyfengtao.github.io/2018/08/20/React学习—一/ </a>
<div>
<strong>版权声明</strong>:本博客所有文章除特别声明外，均采用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" >CC BY-NC-SA 3.0 CN许可协议</a>进行许可。转载请注明出处！
</div>
</blockquote>
</div>

	

    
    <div class="cat-and-tags">
    
    <div class="show-tags">
<ul>



<li>



<a href=http:lilyfengtao.github.io/tags/react >
<i class="fa fa-tags" aria-hidden="true"></i>
react
</a>
</li>


</ul>
</div>


    </div>
    
    <!--注意网易云跟贴url位置必须在网易网站配置中的网站域名之下，比如当我在localhost下设置的时候哦
就会因为与网易网站设置的域名不匹配而导致跟贴不能显示出来
-->


<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
<script>

var pathname=document.location.pathname
var cloudTieConfig = {
  url: "http:lilyfengtao.github.io"+pathname, 
  sourceId: "uuuu",
  productKey: "d9ac976925074859942b446f585903fd",
  target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script>

  </div>
 
 
  <!--上一篇下一篇 -->
  
    
<nav id="article-nav">
  
    <a href="/2018/04/01/Vue中关于路由/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Vue中关于路由
        
      </div>
    </a>
  
  
</nav>

  

</div>
</article>

      <footer id="footer">
  <div class="outer">
     
     <div id="footer-info" class="inner">
     
      &copy;  2014 - 2018 
       李锋涛<br>

      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      </br>
      theme <a href="http://github.com/zhangolve/olive">olive</a> by zhangolve
      </div>
      
      
     


     
    
  </div>
  <div class="to-top">
    <div class="toTop-btn">
    <div class="toTop-text">返回顶部</div>
  	<button class="toTop-button">
  		<i class="fa fa-arrow-up" aria-hidden="true"></i>
  	</button >
    </div>
  </div>
</footer>
     
    
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'http://www.lifengtao.cn/', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


<script src="/js/qrcode.js"></script>
<script src="/js/script.js"></script>
<script src="/js/lightmode.js"></script>

<script src="/js/iewarn.js"></script>


  
</body>
</html>